# API 代理功能更新

## 新增功能

### 1. 智能重试机制

当 API 调用失败时，系统会根据以下条件自动重试一次：

#### 重试条件
- **条件1**：今天前3次调用中有失败
- **条件2**：最近3次调用中有成功

#### 工作流程
1. 首次请求失败时，系统检查是否满足重试条件
2. 如果满足条件，等待1秒后自动重试一次
3. 对每个客户端请求最多重试1次（不会无限重试）
4. 重试次数会记录在调试日志中

#### 示例场景
- 今天已有2次成功调用，第3次失败 → 自动重试
- 最近3次调用中有1次成功，当前失败 → 自动重试
- 今天第1次调用就失败 → 自动重试
- 最近3次调用全部失败，当前也失败 → 不重试

### 2. 并发控制

系统限制同时处理的请求数量，防止过载。

#### 配置方式
在 `.env` 文件中设置：
```
MAX_CONCURRENT_REQUESTS=5
```

#### 工作原理
- 每个新请求到达时，检查当前活跃请求数
- 如果达到限制，等待1秒后重新检查
- 当有请求完成时，立即释放槽位供新请求使用
- 实现了简单的队列机制

#### 并发流程
```
请求1 → 获取槽位 → 处理中
请求2 → 获取槽位 → 处理中
请求3 → 获取槽位 → 处理中
请求4 → 获取槽位 → 处理中
请求5 → 获取槽位 → 处理中
请求6 → 等待... → 等待... → 请求1完成 → 获取槽位 → 处理中
```

## 配置参数

### .env 文件配置

```properties
# 最大并发请求数（可选，默认为5）
MAX_CONCURRENT_REQUESTS=5

# 其他现有配置
OPENROUTER_API_KEY=your_api_key
CACHE_DIR=path/to/cache
HTTP_PROXY=http://proxy:port
```

## 监控和调试

### 新增 API 端点

#### 1. 并发状态查询
```
GET /debug/concurrency
```

返回示例：
```json
{
  "concurrency": {
    "active_requests": 3,
    "max_concurrent": 5,
    "available_slots": 2
  },
  "call_history": [
    {
      "success": true,
      "timestamp": "2024-01-15T10:30:45.123456",
      "date": "2024-01-15"
    },
    {
      "success": false,
      "timestamp": "2024-01-15T10:30:40.654321",
      "date": "2024-01-15"
    }
  ],
  "today_stats": {
    "total": 10,
    "success": 8,
    "failed": 2
  },
  "retry_eligible": true
}
```

#### 2. 调试统计信息
```
GET /debug/stats
```

返回今天的调用统计。

#### 3. 调试面板
```
GET /debug
```

访问可视化调试面板，查看实时统计和测试聊天功能。

## 日志输出

### 并发相关日志
```
[并发] 等待中... (当前: 5/5)
[并发] 请求完成 (当前: 4/5)
```

### 重试相关日志
```
[请求] 发送到 OpenRouter (尝试 1/2)
[请求] 失败 (尝试 1/2): Connection timeout
[重试] 触发重试机制，准备重试...
[请求] 发送到 OpenRouter (尝试 2/2)
[请求] 成功 (尝试 2/2)
```

## 性能考虑

### 并发控制的优势
- 防止服务器过载
- 避免 API 限流
- 提高整体吞吐量
- 可配置以适应不同场景

### 重试机制的优势
- 提高请求成功率
- 自动恢复临时故障
- 不会无限重试（最多1次）
- 智能判断是否需要重试

## 故障排查

### 问题：请求一直在等待
**原因**：并发数已满，有其他请求在处理
**解决**：
1. 检查 `/debug/concurrency` 端点
2. 增加 `MAX_CONCURRENT_REQUESTS` 值
3. 等待现有请求完成

### 问题：没有触发重试
**原因**：不满足重试条件
**解决**：
1. 检查 `/debug/concurrency` 中的 `retry_eligible` 字段
2. 确保最近有成功的调用或今天前3次有失败
3. 查看日志中的 `[重试] 不满足重试条件` 消息

### 问题：重试次数过多
**原因**：系统设计限制每个请求最多重试1次
**解决**：
1. 检查 API 密钥是否有效
2. 检查网络连接
3. 查看 OpenRouter API 状态

### 3. 分类统计功能

#### 统计数据

调试模式下，会分类统计调用情况：

**文件位置:** `{CACHE_DIR}/CALLS_YYYYMMDD.json`

```json
{
  "date": "20260216",
  "total": 10,
  "success": 7,
  "failed": 2,
  "timeout": 1,
  "retry": 3,
  "last_updated": "2026-02-16T20:30:45.123456"
}
```

| 字段 | 说明 |
|------|------|
| `total` | 总调用次数 |
| `success` | 成功次数 |
| `failed` | 失败次数（不包括超时） |
| `timeout` | 超时次数 |
| `retry` | 自动重试次数 |

#### 统计规则
- 每次成功的 API 响应 → `success + 1`，`total + 1`
- 每次失败的响应（非超时）→ `failed + 1`，`total + 1`
- 每次超时的响应 → `timeout + 1`，`total + 1`
- 每次触发重试 → `retry + 1`（不增加 total）

### 4. 守护进程

#### 功能特性
- **自动重启**：主程序异常退出时自动重启
- **单例保护**：防止重复启动多个实例
- **重启限制**：每 60 秒最多重启 10 次，超过则停止
- **日志记录**：所有操作写入 `daemon.log`

#### 使用方法
```bash
# 启动守护进程
python daemon.py start
# 或双击
010-start_proxy_daemon-start.bat

# 查看状态
python daemon.py status

# 停止守护进程
python daemon.py stop

# 重启守护进程
python daemon.py restart
```

#### 文件说明
- `daemon.py` - 守护进程核心脚本
- `daemon.pid` - PID 文件（自动生成）
- `daemon.log` - 日志文件

#### 工作原理
1. 守护进程启动主程序 `local_api_proxy.py`
2. 每秒检查主程序是否存活
3. 如果主程序异常退出，自动重启
4. 如果在 60 秒内重启超过 10 次，停止并报警
5. 正常退出（exit code = 0）不会触发重启
